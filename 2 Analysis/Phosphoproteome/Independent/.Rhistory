BiocManager::install("multiClust")
library(multiClust)
} # package containing min/max normalisation function - NB: you need R version ≥ 3.6.0 for this!
if (!require("gplots")) {
install.packages("gplots", dependencies = TRUE)
library(gplots)
}
if (!require("RColorBrewer")) {
install.packages("RColorBrewer", dependencies = TRUE)
library(RColorBrewer)
}
if (!require("gridExtra")) {
install.packages("gridExtra", dependencies = TRUE)
library(gridExtra)
}
# Make a list of all the .csv files in your working directory just so you can see what's going on
X = list.files(".",".csv")
# read the raw data files for WT
WT_data_start <- read_csv("WT.p_all_hits.csv", col_names = TRUE)
WT_data_only <- as_tibble(WT_data_start[11:ncol(WT_data_start)]) # Take only the data columns
WT_norm_data <- as_tibble(t(apply(WT_data_only, 1, nor.min.max))) # Min-max normalise each protein, then transform the resulting matrix (the apply function gives the results in columns instead of rows), then convert it into a tibble
WT_norm_data <- cbind(WT_data_start[,1:10], WT_norm_data) # Attach the protein names and stats to the min-max normalised data
WT_sorted_input <- WT_norm_data %>% arrange(phase) #sort the data according to phase
# SAME FOR CKO
CKO_data_start <- read_csv("CKO.p_all_hits.csv", col_names = TRUE)
CKO_data_only <- as_tibble(CKO_data_start[11:ncol(CKO_data_start)])
CKO_norm_data <- as_tibble(t(apply(CKO_data_only, 1, nor.min.max)))
CKO_norm_data <- cbind(CKO_data_start[,1:10], CKO_norm_data)
CKO_sorted_input <- CKO_norm_data %>% arrange(phase)
#Create PDF for the heat map
pdf("CKO.p_Total_heatmap.pdf",
width = 5,
height = 7,
pointsize = 6)        # smaller font size
#Plot the heatmap of min-max normalised intensities of all rhythmic phosphopeptides, sorted in order of phase
Colours = rev(brewer.pal(5,"Spectral")) #Load a colour palette
Colours <- colorRampPalette(Colours)(10)
Breaks = seq(0, 1, 0.1)
key_breaks = seq(0, 1, 0.5)
heatmap.2(as.matrix(CKO_sorted_input[11:ncol(CKO_sorted_input)]),
Rowv = FALSE,
Colv = FALSE,
col = Colours,
breaks = Breaks,
scale = "row",
trace="none",
density.info="none",
dendrogram='none',
main = " ",
na.color='grey',
key=TRUE,
key.xlab = "Value",
keysize = 1,
symkey = FALSE,
key.xtickfun = function() {
list(at = parent.frame()$scale01(key_breaks),
labels = key_breaks)
},
lhei = c(1,10),
labRow = FALSE,
labCol = seq(24,93,by=3),
margins=c(12,12)
)
dev.off()               # close the PDF device
pdf("WT.p_Total_heatmap.pdf",
width = 5,
height = 7,
pointsize = 6)        # smaller font size
#Plot the heatmap of min-max normalised intensities of all rhythmic phosphopeptides, sorted in order of phase
Colours = rev(brewer.pal(5,"Spectral")) #Load a colour palette
Colours <- colorRampPalette(Colours)(10)
Breaks = seq(0, 1, 0.1)
key_breaks = seq(0, 1, 0.5)
heatmap.2(as.matrix(WT_sorted_input[11:ncol(WT_sorted_input)]),
Rowv = FALSE,
Colv = FALSE,
col = Colours,
breaks = Breaks,
scale = "row",
trace="none",
density.info="none",
dendrogram='none',
main = " ",
na.color='grey',
key=TRUE,
key.xlab = "Value",
keysize = 1,
symkey = FALSE,
key.xtickfun = function() {
list(at = parent.frame()$scale01(key_breaks),
labels = key_breaks)
},
lhei = c(1,10),
labRow = FALSE,
labCol = seq(24,93,by=3),
margins=c(12,12)
)
dev.off()               # close the PDF device
# Setup
# Clear your workspace
rm(list=ls())
# Load useful packages
if (!require("tidyverse")) {
install.packages("tidyverse", dependencies = TRUE)
library(tidyverse)
}
if (!require("BiocManager")) {
install.packages("BiocManager", dependencies = TRUE)
}
if (!require("multiClust")) {
BiocManager::install("multiClust")
library(multiClust)
} # package containing min/max normalisation function - NB: you need R version ≥ 3.6.0 for this!
if (!require("gplots")) {
install.packages("gplots", dependencies = TRUE)
library(gplots)
}
if (!require("RColorBrewer")) {
install.packages("RColorBrewer", dependencies = TRUE)
library(RColorBrewer)
}
if (!require("circular")) {
install.packages("circular", dependencies = TRUE)
library(circular)
}
if (!require("gridExtra")) {
install.packages("gridExtra", dependencies = TRUE)
library(gridExtra)
}
# Make a list of all the .csv files in your working directory just so you can see what's going on
X = list.files(".",".csv")
# read the raw data files for WT
WT_data_start <- read_csv("WT.p_all_hits.csv", col_names = TRUE)
WT_data_only <- as_tibble(WT_data_start[11:ncol(WT_data_start)]) # Take only the data columns
WT_norm_data <- as_tibble(t(apply(WT_data_only, 1, nor.min.max))) # Min-max normalise each protein, then transform the resulting matrix (the apply function gives the results in columns instead of rows), then convert it into a tibble
WT_norm_data <- cbind(WT_data_start[,1:10], WT_norm_data) # Attach the protein names and stats to the min-max normalised data
WT_sorted_input <- WT_norm_data %>% arrange(phase) #sort the data according to phase
# SAME FOR CKO
CKO_data_start <- read_csv("CKO.p_all_hits.csv", col_names = TRUE)
CKO_data_only <- as_tibble(CKO_data_start[11:ncol(CKO_data_start)])
CKO_norm_data <- as_tibble(t(apply(CKO_data_only, 1, nor.min.max)))
CKO_norm_data <- cbind(CKO_data_start[,1:10], CKO_norm_data)
CKO_sorted_input <- CKO_norm_data %>% arrange(phase)
# Plot circular histograms
axis_colour = "grey85"
axis_text_size = 10
WT_phase <- ggplot(WT_sorted_input, aes(x = phase)) +
geom_hline(yintercept = seq(0, 100, by = 20), colour = axis_colour, size = 0.2) +
geom_vline(xintercept = seq(3, 24, 3), colour = axis_colour, size = 0.2) +
geom_histogram(binwidth=3, aes(fill = ..count..)) +
scale_x_continuous(name = "WT \nRelative amplitude >10%",
breaks = seq(3, 24, 3),
position = "top") +
scale_fill_gradient("Count", low="blue", high="red") +
theme(axis.text.x = element_text(color = "black", size = axis_text_size, vjust = 0),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
panel.grid = element_blank(),
panel.border = element_blank(),
plot.background = element_rect(fill="transparent"),
panel.background = element_rect(fill = "transparent"),
legend.box.background = element_blank(),
legend.text = element_text(size = axis_text_size)
) +
coord_polar(theta = "x", start = (22.5*pi)/180, direction = 1) # CHANGE THE ANGLE IN TO ALTER ROTATION - must be in radians, or just add to the formula
CKO_phase <- ggplot(CKO_sorted_input, aes(x = phase)) +
geom_hline(yintercept = seq(0, 150, by = 50), colour = axis_colour, size = 0.2) +
geom_vline(xintercept = seq(3, 24, 3), colour = axis_colour, size = 0.2) +
geom_histogram(binwidth=3, aes(fill = ..count..)) +
scale_x_continuous(name = "CKO \nRelative amplitude >10%",
breaks = seq(3, 24, 3),
position = "top") +
scale_fill_gradient("Count", low="blue", high="red") +
theme(axis.text.x = element_text(color = "black", size = axis_text_size, vjust = 0),
axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
panel.grid = element_blank(),
panel.border = element_blank(),
plot.background = element_rect(fill="transparent"),
panel.background = element_rect(fill = "transparent"),
legend.box.background = element_blank(),
legend.text = element_text(size = axis_text_size)
) +
coord_polar(theta = "x", start = (22.5*pi)/180, direction = 1) # CHANGE THE ANGLE IN TO ALTER ROTATION - must be in radians, or just add to the formula
pdf("Phase_maps_phospho.pdf")
grid.arrange(WT_phase, CKO_phase, nrow = 1)
dev.off()
grid.arrange(WT_phase, CKO_phase, nrow = 1)
#######################################################################################################################################
# Do circular statistics
# NB: Circular Statistics in R (Pewsey et al. 2013) - a very good book to read, and justification for the analysis method.
#######################################################################################################################################
# Set up dataframes and convert phase into angles in radians
WT <- WT_sorted_input[,1:8]
CKO <- CKO_sorted_input[,1:8]
WT$angle <- as.circular(WT$phase *(pi/12)) # convert phase into angle in radians
CKO$angle <- as.circular(CKO$phase *(pi/12))
#######################################################################################################################################
# Watson's test for a common distribution (two samples)
# Null hypothesis: the two datasets are drawn from the same circular distribution.
#######################################################################################################################################
watson.two.test(WT$angle, CKO$angle)
# Setup
# Clear your workspace
rm(list=ls())
# Load useful packages
if (!require("tidyverse")) {
install.packages("tidyverse", dependencies = TRUE)
library(tidyverse)
}
#make a list of all the .csv and .txt files in your working directory just so you can see what's going on
X = list.files(".",".csv")
Y = list.files(".",".txt")
# read the raw data files
data_start <- read.delim("CRM3962_6set_MQ1633C_phos_noFil_m8b.txt", na = c("NaN"), stringsAsFactors = F) # Need this file for the sequences
data_start <- data_start[-1, -1:-60] # Remove the first row which is just junk, and all data columns
WT_data <- read.csv("WT.p_all_hits.csv", stringsAsFactors = F)
CKO_data <- read.csv("CKO.p_all_hits.csv", stringsAsFactors = F)
WT_total <- read.csv("WT.p_RAIN_results.csv", stringsAsFactors = F)
CKO_total <- read.csv("CKO.p_RAIN_results.csv", stringsAsFactors = F)
# Fix gene names and phosphosites in original data set
total_genes <- toupper(data_start$Gene.names)
total_genes_list <- vector("list", length(data_start$Gene.names))
for (i in 1:length(total_genes)) {
total_genes_list[i] <- strsplit(total_genes[i], ";")
}
total_genes_list <- unlist(lapply(total_genes_list, '[', 1))
data_start$Phosphosite_proteins <- paste(data_start$Protein, "_", data_start$Amino.acid, data_start$Position, data_start$Multiplicity, sep = "")
data_start$Phosphosite_genes <- paste(total_genes_list, "_", data_start$Amino.acid, data_start$Position, data_start$Multiplicity, sep = "")
# Separate out the main sequnces
sequences <- data_start$Sequence.window
main_sequences <- vector("list", length(sequences)) # Create empty vector
# For loop to either print the name or separate them if there are several in one line
for (i in 1:length(sequences)) {
main_sequences[i] <- strsplit(sequences[i], ";")
}
# Select only the first element on each line --> this is the main protein for each line then attach it to the first column of the total proteome dataframe
sequences <- unlist(lapply(main_sequences, '[[', 1))
data_start$main_sequence <- sequences
# Define the background phosphoproteome - i.e. all unique proteins even if only present in one genotype
background_phosphosites <- unique(c(WT_total$Phosphosite, CKO_total$Phosphosite))
total_background <- data_start[which(data_start$Phosphosite_proteins %in% background_phosphosites), ]
write.csv(total_background, "Background_phosphosites.p.csv", row.names = F)
# Extract from total dataset only the phosphosites that are present in both CKO + WT
common_things <- data_start[which(data_start$Phosphosite_proteins %in% intersect(CKO_data$Phosphosite, WT_data$Phosphosite)), 24:ncol(data_start)]
# Select pVal + relative amplitude for the intersecting proteins
for (i in 1:nrow(common_things)) {
common_things$WT_pVal[i] <- WT_data[which(WT_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 6]
common_things$CKO_pVal[i] <- CKO_data[which(CKO_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 6]
common_things$WT_RA[i] <- WT_data[which(WT_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 10]
common_things$CKO_RA[i] <- CKO_data[which(CKO_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 10]
common_things$Gene_names[i] <- CKO_data[which(CKO_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 4]
common_things$Protein_names[i] <- CKO_data[which(CKO_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 3]
common_things$WT_phase[i] <- WT_data[which(WT_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 7]
common_things$CKO_phase[i] <- CKO_data[which(CKO_data$Phosphosite %in% common_things$Phosphosite_proteins[i]), 7]
}
# Make those columns numeric
common_things$WT_pVal <- as.numeric(common_things$WT_pVal)
common_things$CKO_pVal <- as.numeric(common_things$CKO_pVal)
common_things$WT_RA <- as.numeric(common_things$WT_RA)
common_things$CKO_RA <- as.numeric(common_things$CKO_RA)
common_things$WT_phase <- as.numeric(common_things$WT_phase)
common_things$CKO_phase <- as.numeric(common_things$CKO_phase)
common_things_data <- cbind(WT_data[which(WT_data$Phosphosite %in% common_things$Phosphosite_proteins), 11:ncol(WT_data)],
CKO_data[which(CKO_data$Phosphosite %in% common_things$Phosphosite_proteins), 11:ncol(CKO_data)])
colnames(common_things_data) <- c(paste("WT", seq(1:24)), paste("CKO", seq(1:24)))
common_phosphosite_list <- cbind(Phosphosite_proteins = common_things$Phosphosite_proteins,
Phosphosite_genes = common_things$Phosphosite_genes,
Phosphosite_gene_names = common_things$Gene_names,
Protein_names = common_things$Protein_names,
Main_sequence = common_things$main_sequence,
WT_pVal = common_things$WT_pVal,
CKO_pVal = common_things$CKO_pVal,
WT_Relative_amplitude = common_things$WT_RA,
CKO_Relative_amplitude = common_things$CKO_RA,
WT_phase = common_things$WT_phase,
CKO_phase = common_things$CKO_phase,
common_things_data)
write.csv(common_phosphosite_list, "Common_phosphosites_list.csv", row.names = F)
#Draw Venn diagram
if (!require("VennDiagram")) {
install.packages("VennDiagram", dependencies = TRUE)
library(VennDiagram)
}
overlap <- calculate.overlap(x = list("WT" = WT_data$Phosphosite, "CKO" = CKO_data$Phosphosite)) #calculate overlap to pass into venn diagram function
venn.plot <- draw.pairwise.venn(length(overlap$a1),
length(overlap$a2),
length(overlap$a3),
euler.d = TRUE,
scaled = TRUE,
rotation.degree = 180,
fill = c("blue", "red"),
alpha = c(0.4, 0.4),
lty = c(0,0),
cex = 2,
cat.cex = 2.5,
cat.dist = c(0.001, 0.01),
cat.prompts = TRUE
)
pdf("Venn_diagram_phospho.pdf", width = 5, height = 5)
grid.draw(venn.plot)
dev.off()
350/4273
551/
3977
# Setup
# Clear your workspace
rm(list=ls())
# Load useful packages
if (!require("tidyverse")) {
install.packages("tidyverse", dependencies = TRUE)
library(tidyverse)
}
if (!require("gridExtra")) {
install.packages("gridExtra", dependencies = TRUE)
library(gridExtra)
}
if (!require("Matching")) {
install.packages("Matching", dependencies = TRUE)
library(Matching)
}
library(reshape2)
#make a list of all the .csv files in your working directory just so you can see what's going on
X = list.files(".",".csv")
# read the raw data files
WT_hits <- read.csv("WT.p_all_hits.csv", stringsAsFactors = FALSE)
WT_hits <- WT_hits[, 1:10]
CKO_hits <- read.csv("CKO.p_all_hits.csv", stringsAsFactors = FALSE)
CKO_hits <- CKO_hits[, 1:10]
# Log10 transform of relative amplitudes
WT_hits$Log10RA <- log10(WT_hits$WT_Relative_amplitudes)
CKO_hits$Log10RA <- log10(CKO_hits$CKO_Relative_amplitudes)
t.test(WT_hits$Log10RA, CKO_hits$Log10RA) # t test with Welch correction
# Setup
# Clear your workspace
rm(list=ls())
# Load useful packages
if (!require("tidyverse")) {
install.packages("tidyverse", dependencies = TRUE)
library(tidyverse)
}
if (!require("gridExtra")) {
install.packages("gridExtra", dependencies = TRUE)
library(gridExtra)
}
if (!require("Matching")) {
install.packages("Matching", dependencies = TRUE)
library(Matching)
}
library(reshape2)
#make a list of all the .csv files in your working directory just so you can see what's going on
X = list.files(".",".csv")
# read the raw data files
WT_hits <- read.csv("WT.p_all_hits.csv", stringsAsFactors = FALSE)
WT_hits <- WT_hits[, 1:10]
CKO_hits <- read.csv("CKO.p_all_hits.csv", stringsAsFactors = FALSE)
CKO_hits <- CKO_hits[, 1:10]
# Log10 transform of relative amplitudes
WT_hits$Log10RA <- log10(WT_hits$WT_Relative_amplitudes)
CKO_hits$Log10RA <- log10(CKO_hits$CKO_Relative_amplitudes)
t.test(WT_hits$Log10RA, CKO_hits$Log10RA) # t test with Welch correction
# How many CKO rhythmic proteins are rhythmic in WT but below the 10% RA threshold?
common_site <- intersect(CKO_hits$Phosphosite, WT_hits$Phosphosite)
common_list <- cbind(common_site)
common_list <- as.data.frame(common_list)
common_list <- as.data.frame(common_list[!is.na(common_list)])
colnames(common_list) <- c("common_site")
# Select pVal + relative amplitude for the intersecting proteins
for (i in 1:nrow(common_list)) {
common_list$main_gene[i] <- WT_hits[which(WT_hits$Phosphosite %in% common_list$common_site[i]), 4]
common_list$Protein_names[i] <- WT_hits[which(WT_hits$Phosphosite %in% common_list$common_site[i]), 3]
common_list$WT_pVal[i] <- WT_hits[which(WT_hits$Phosphosite %in% common_list$common_site[i]), 6]
common_list$CKO_pVal[i] <- CKO_hits[which(CKO_hits$Phosphosite %in% common_list$common_site[i]), 6]
common_list$WT_RA[i] <- WT_hits[which(WT_hits$Phosphosite %in% common_list$common_site[i]), 10]
common_list$CKO_RA[i] <- CKO_hits[which(CKO_hits$Phosphosite %in% common_list$common_site[i]), 10]
}
colnames(common_list) <- c("Phosphosite", "main_gene", "Protein_names", "WT pVal", "CKO pVal", "WT Relative Amplitude", "CKO Relative Amplitude")
a <- common_list
a$amplification <- a$`CKO Relative Amplitude` / a$`WT Relative Amplitude`
a$logamp <- log10(a$amplification)
write.csv(a, "CKO.p_all_amplified_proteins.csv", row.names = F)
# Setup
# Clear your workspace
rm(list=ls())
# Load useful packages
if (!require("tidyverse")) {
install.packages("tidyverse", dependencies = TRUE)
library(tidyverse)
}
if (!require("seqinr")) {
install.packages("seqinr", dependencies = TRUE)
library(seqinr)
}
# Make a list of all the .csv files in your working directory just so you can see what's going on
X = list.files(".",".csv")
WT_data <- read.csv("WT.p_all_hits.csv", stringsAsFactors = F)
CKO_data <- read.csv("CKO.p_all_hits.csv", stringsAsFactors = F)
common_data <- read.csv("Common_phosphosites_list.csv", stringsAsFactors = F)
background <- read.csv("Background_phosphosites.p.csv", stringsAsFactors = F)
# Select WT and CKO data from background in order to get the sequences!
WT_selection <- background[which(background$Phosphosite_proteins %in% WT_data$Phosphosite),]
CKO_selection <- background[which(background$Phosphosite_proteins %in% CKO_data$Phosphosite),]
# Make fasta files
write.fasta(as.list(WT_selection$main_sequence), WT_selection$Phosphosite_proteins, "WT.fasta", open = "w", as.string = FALSE)
write.fasta(as.list(CKO_selection$main_sequence), CKO_selection$Phosphosite_proteins, "CKO.fasta", open = "w", as.string = FALSE)
write.fasta(as.list(common_data$Main_sequence), common_data$Phosphosite_proteins, "Overlap.fasta", open = "w", as.string = FALSE)
write.fasta(as.list(background$main_sequence), background$Phosphosite_proteins, "Background.fasta", open = "w", as.string = FALSE)
View(CKO_selection)
# Setup
# Clear your workspace
rm(list=ls())
# Load useful packages
if (!require("tidyverse")) {
install.packages("tidyverse", dependencies = TRUE)
library(tidyverse)
}
if (!require("gridExtra")) {
install.packages("gridExtra", dependencies = TRUE)
library(gridExtra)
}
if (!require("Matching")) {
install.packages("Matching", dependencies = TRUE)
library(Matching)
} # This is for ks.boot
#read the RAIN files from independent analysis, with correct primary IDs
WT_data <- read.csv("WT RAIN corrected ID.csv", stringsAsFactors = F)
CKO_data <- read.csv("CKO RAIN corrected ID.csv", stringsAsFactors = F)
#rhythmic lists with relative amplitude from independent analysis
WT_rhy <- read.csv("rhythmic WT corrected ID.csv", stringsAsFactors = F)
CKO_rhy <- read.csv("rhythmic CKO corrected ID.csv", stringsAsFactors = F)
#read in the half-life data - in this case from McShane et al Cell 2016, done in NIH 3T3 with AHA
prot_stab <- read.csv("McShane et al prot stability 3t3.csv", stringsAsFactors = F)
#they have 2 degradation profiles (exponential and non-exponential), so separate based on that and select half life
prot_ned <- subset(prot_stab, prot_stab$Degradation.profile == "NED")
prot_ed <- subset(prot_stab, !(prot_stab$Degradation.profile == "NED"))
cn <- c("Uniprot_ID", "Half_life", "Deg profile")
#pick the one-phase decay half-life value for ED proteins, and 2-phase for NED - how they describe in the paper
prot_ned_s <- prot_ned[,c(1,39,41)]
prot_ed_s <- prot_ed[,c(1,38,41)]
colnames(prot_ned_s) <- cn
colnames(prot_ed_s) <- cn
prot_hl <- rbind(prot_ned_s, prot_ed_s)
#make numeric; have >300h half-life for some proteins that because of > gets converted to NAs - will be just excluded from correlations, fine for now
prot_hl$Half_life <- as.numeric(prot_hl$Half_life)
#merge rhythmicity and half-life data
WT_rhy_hl <- merge(WT_rhy, prot_hl, by="Uniprot_ID")
CKO_rhy_hl <- merge(CKO_rhy, prot_hl, by="Uniprot_ID")
#although CKO for sure have proteostasis defects, so half-lives would be altered -> probably even less valid to use this dataset
WT_all_hl <- merge(WT_data, prot_hl, by="Uniprot_ID")
CKO_all_hl <- merge(CKO_data, prot_hl, by="Uniprot_ID")
#also calculate again baseline (=average abundance across timepoints)
WT_rhy_hl$Baseline <- rowMeans(WT_rhy_hl[,9:32])
CKO_rhy_hl$Baseline <- rowMeans(CKO_rhy_hl[,9:32])
WT_all_hl$Baseline <- rowMeans(WT_all_hl[,8:31])
CKO_all_hl$Baseline <- rowMeans(CKO_all_hl[,8:31])
##########################
# Adding in some spice to the theme to adjust the background and axis text appearance only!
##########################
#create function for plotting and testing distributions (taken from abundance and rhythmicity script)
#set colours
colours <- c("WT Rhythmic" = "orange", "WT Background" = "navy", "CKO Rhythmic" = "red", "CKO Background" = "dark green", "WT Random"="orange", "CKO Random"="red", "WT Not Rhythmic" = "navy", "CKO Not Rhythmic" = "dark green")
#function
probability_plots <- function(x1, x2, n1, n2, xn) {
pd <- ggplot() +
geom_density(aes(x = log10(x1), fill = n1),
color = "black", alpha = 0.5) +
geom_density(aes(x = log10(x2), fill = n2),
color = "black", alpha = 0.5) +
scale_fill_manual(name = "", values = colours) +
labs(x =xn, y = "Probability density") +
theme(panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.ticks = element_line(colour = "black"),
axis.line = element_line(colour = "black"),
axis.text=element_text(colour="black"),
legend.background = element_blank(),
legend.key = element_blank()
)
st <- ks.boot(x1, x2, nboots=1000)
cp <- ggplot() +
geom_step(aes(x=log10(x1), colour = n1), stat="ecdf") +
geom_step(aes(x=log10(x2), colour = n2), stat="ecdf") +
scale_color_manual(name = "", values = colours) +
labs(subtitle = paste("KS test p-val: ", format(round(st$ks.boot.pvalue,4))), y="Cumulative probability", x=xn) +
theme(panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.ticks = element_line(colour = "black"),
axis.line = element_line(colour = "black"),
axis.text=element_text(colour="black"),
legend.background = element_blank(),
legend.key = element_blank()
)
grid.arrange(pd, cp, nrow=2)
}
#plotting against not rhythmic
WT_nonrhy_hl <- subset(WT_all_hl, pVal > 0.05)
CKO_nonrhy_hl <- subset(CKO_all_hl, pVal > 0.05)
WT_rvnr <- probability_plots(WT_rhy_hl$Half_life, WT_nonrhy_hl$Half_life, "WT Rhythmic", "WT Not Rhythmic", "Log10(Half-life)")
CKO_rvnr <- probability_plots(CKO_rhy_hl$Half_life, CKO_nonrhy_hl$Half_life, "CKO Rhythmic", "CKO Not Rhythmic", "Log10(Half-life)")
p <- grid.arrange(WT_rvnr, CKO_rvnr, nrow=1)
ggsave(plot=p, "WT and CKO rhythmic vs not rhythmic half-life DAVID.pdf", width=8, height = 5)
median(na.omit(WT_rhy_hl$Half_life)) #32.4h
median(na.omit(WT_nonrhy_hl$Half_life)) #27.3h
median(na.omit(CKO_rhy_hl$Half_life)) #31.4h
median(na.omit(CKO_nonrhy_hl$Half_life)) #26.6h
boxplot((na.omit(WT_rhy_hl$Half_life)), na.omit(WT_nonrhy_hl$Half_life))
