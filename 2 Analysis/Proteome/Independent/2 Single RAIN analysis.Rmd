---
title: "RAIN analysis"
output: 
---

```{r}
#######################################################################################################################################
# Independent analysis Notebook 2 - DESCRIPTION
#
# Here we take the normalised data and perform Rhythmicity Analysis Incorporating Non-parametric methods (RAIN).
# Thaben and Westermark, 2014, JBR. https://journals.sagepub.com/doi/10.1177/0748730414553029
# This algorithm is used because it is more sensitive than alternatives. The tradeoff is a higher false positive rate.
# We deem this acceptable since proteomics studies need to be followed by validation studies.
#
# INPUTS = normalised data (.csv)
# OUTPUTS = lists of rhythmic proteins, arrhythmic proteins, and also full list of RAIN results (.csv)
# 
#######################################################################################################################################
```

```{r}
# Setup

# Clear your workspace
rm(list=ls())

# Load useful packages
if (!require("tidyverse")) {
  install.packages("tidyverse", dependencies = TRUE)
  library(tidyverse)
}

if (!require("BiocManager")) {
  install.packages("BiocManager", dependencies = TRUE)
}

if (!require("rain")) {
  BiocManager::install("rain")
  library(rain)
}

# Make a list of all the .txt files in your working directory just so you can see what's going on
X = list.files(".",".csv")

# read the raw data file
WT_data_start <- read.csv("All_WT_normalised_data.csv")
CKO_data_start <- read.csv("All_CKO_normalised_data.csv")

# re-create dataframe with just normalised data - delete first 3 columns
WT_data_irs <- WT_data_start[,-1:-3]
CKO_data_irs <- CKO_data_start[,-1:-3]

```



```{r}
#Transpose to create the inputs for RAIN.

WT_RAIN_input <- t(WT_data_irs)
CKO_RAIN_input <- t(CKO_data_irs)

#create matrix for RAIN output
WT_RAIN_output <- as.data.frame(matrix(0,nrow(WT_RAIN_input), 4))
CKO_RAIN_output <- as.data.frame(matrix(0,nrow(CKO_RAIN_input), 4))

#Perform RAIN analysis
step = 3 #number of hours between timepoints
period = 24 #specify period length to test for
rep = 1 #number of biological replicates

# Perform the RAIN analysis here
# RAIN automatically provides p values corrected for multiple testing using the adaptive Benjamini-Hochberg method
# See the paper for more details: Thaben and Westermark, 2014, JBR. https://journals.sagepub.com/doi/10.1177/0748730414553029

WT_RAIN_output <- rain(WT_RAIN_input, step, period, nr.series = rep)
CKO_RAIN_output <- rain(CKO_RAIN_input, step, period, nr.series = rep)

#Assign gene names to the rows
WT_names <- WT_data_start[, 1:3]
CKO_names <- CKO_data_start[, 1:3]

WT_RAIN_output_1 <- cbind(WT_names, WT_RAIN_output)
CKO_RAIN_output_1 <- cbind(CKO_names, CKO_RAIN_output)

colnames(WT_RAIN_output_1) <- c("Uniprot_ID",  "Gene_names", "Protein_names", "pVal", "phase", "peak.shape", "period")
colnames(CKO_RAIN_output_1) <- c("Uniprot_ID",  "Gene_names", "Protein_names", "pVal", "phase", "peak.shape", "period")

#Export the significant + insignificant hits including normalised data + also export total data

WT_results<- cbind(WT_RAIN_output_1, WT_data_irs)
CKO_results <- cbind(CKO_RAIN_output_1, CKO_data_irs)

write.csv(WT_results[WT_results$pVal <= 0.05,], "WT_proteome_all_significant_RAIN.csv", row.names = F)
write.csv(CKO_results[CKO_results$pVal <= 0.05,], "CKO_proteome_all_significant_RAIN.csv", row.names = F)

write.csv(WT_results[WT_results$pVal > 0.05,], "WT_proteome_all_insignificant_RAIN.csv", row.names = F)
write.csv(CKO_results[CKO_results$pVal > 0.05,], "CKO_proteome_all_insignificant_RAIN.csv", row.names = F)

write.csv(WT_results, "WT_RAIN_results.csv", row.names = F)
write.csv(CKO_results, "CKO_RAIN_results.csv", row.names = F)

```

```{r}
# Explore how number of rhythmic hits changes as a function of p value cutoff

if (!require("gridExtra")) {
  install.packages("gridExtra", dependencies = TRUE)
  library(gridExtra)
}

axis_text_size = 12
axis_label_size = 12

pdist <- function(data) {
  ggplot(data, aes(x = pVal)) + 
  geom_histogram(binwidth = 0.01, col = "white") +
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"),
        axis.text=element_text(colour="black", size = axis_text_size),
        axis.title = element_text(colour = "black", size = axis_label_size)) +
  labs(title = deparse(substitute(data))) +
  ylab("Count")
}

p1 <- pdist(WT_results)
p2 <- pdist(CKO_results)

grid.arrange(p1, p2, nrow = 2)
```


```{r}
# Try to do BH correction on RAIN p values and then look at distribution

if (!require("gridExtra")) {
  install.packages("gridExtra", dependencies = TRUE)
  library(gridExtra)
}

axis_text_size = 12
axis_label_size = 12

WT_results$BH <- p.adjust(WT_results$pVal, method = "BH")
CKO_results$BH <- p.adjust(CKO_results$pVal, method = "BH")

pdistBH <- function(data) {
  ggplot(data, aes(x = BH))+ 
  geom_histogram(col = "white") +
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"),
        axis.text=element_text(colour="black", size = axis_text_size),
        axis.title = element_text(colour = "black", size = axis_label_size)) +
  labs(title = deparse(substitute(data))) +
  ylab("Count")
}

p3 <- pdistBH(WT_results)
p4 <- pdistBH(CKO_results)

grid.arrange(p1, p3, p2, p4, nrow = 2)

```

```{r}
# Calculate critical values

WT_results_ordered <- WT_results[order(WT_results$pVal),]
CKO_results_ordered <- CKO_results[order(CKO_results$pVal),]

pplot <- function(data) {
  ggplot(data, aes(x=pVal, y=BH)) +
    geom_line() +
    xlab("Raw p value") + ylab("BH-corrected p value") +
    ggtitle("Comparison of p values")
}

p5 <- pplot(WT_results_ordered)
p6 <- pplot(CKO_results_ordered)

grid.arrange(p5, p6, nrow = 2)

```